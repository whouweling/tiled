// Generated by CoffeeScript 1.10.0
(function() {
  window.Render = (function() {
    function Render(world, content) {
      this.world = world;
      this.content = content;
      this.tile_width = 36;
      this.tile_height = this.tile_width / 2;
      this.height_multiplier = 14;
      this.el_width = 73;
      this.el_height = 146;
      this.x_offset = Math.round(this.world.width / 2) - 10;
      this.y_offset = Math.round(this.world.height / 2) - 10;
      this.viewport_offset_x = 0;
      this.viewport_offset_y = 0;
      this.viewport_width = 10;
      this.viewport_height = 10;
      this.zoom = 1;
      this.map_context = document.getElementById("map").getContext("2d");
      this.items_context = document.getElementById("items").getContext("2d");
      this.fx_context = document.getElementById("fx").getContext("2d");
    }

    Render.prototype.resize = function() {
      this.viewport_width = parseInt(window.innerWidth / (this.tile_width * this.zoom) / 2, 10);
      this.viewport_height = parseInt(window.innerHeight / (this.tile_height * this.zoom) / 2, 10);
      this.viewport_offset_x = window.innerWidth / 2;
      return this.viewport_offset_y = -120;
    };

    Render.prototype.update = function() {
      this.tiles_resource = this.content.images.tiles;
      this.update_map();
      return this.update_fx();
    };

    Render.prototype.update_fx = function() {
      var effect, height, i, ix, iy, len, ref, results, tile;
      return;
      this.fx_context.clearRect(0, 0, 2000, 2000);
      ref = window.effects;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        effect = ref[i];
        if (!effect) {
          continue;
        }
        effect.run();
        ix = effect.x * this.tile_width - (effect.y * this.tile_width);
        iy = effect.y * this.tile_height + (effect.x * this.tile_height);
        height = this.world.map[effect.x][effect.y].get_vertical_offset();
        tile = this.content.sprites[effect.tile][1];
        results.push(this.fx_context.drawImage(tile, ix + this.viewport_offset_x, (iy + this.viewport_offset_y - height * 3 - 10) + effect.viewport_offset_y));
      }
      return results;
    };

    Render.prototype.draw_tile = function(context, tile, x, y, height, light) {
      if (light < 1) {
        light = 1;
      }
      if (light > 10) {
        light = 10;
      }
      if (!light) {
        light = 1;
      }
      return context.drawImage(this.tiles_resource[light], tile * this.el_width, 0, this.el_width, this.el_height, (x * this.zoom) + this.viewport_offset_x, (y * this.zoom) + this.viewport_offset_y - (height * this.zoom) * this.height_multiplier, this.el_width * this.zoom, this.el_height * this.zoom);
    };

    Render.prototype.update_map = function() {
      var actor, corner, h, height, i, item, ix, iy, light, ox, oy, ref, results, task, tile, x, y;
      this.map_context.clearRect(0, 0, 2000, 2000);
      results = [];
      for (x = i = 1, ref = this.viewport_width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        results.push((function() {
          var j, k, ref1, ref2, results1;
          results1 = [];
          for (y = j = 1, ref1 = this.viewport_height; 1 <= ref1 ? j <= ref1 : j >= ref1; y = 1 <= ref1 ? ++j : --j) {
            ox = x + this.x_offset;
            oy = y + this.y_offset;
            if (ox < 1) {
              continue;
            }
            if (oy < 1) {
              continue;
            }
            if (ox > this.world.width) {
              continue;
            }
            if (oy > this.world.height) {
              continue;
            }
            tile = this.world.map[ox][oy].tile;
            task = this.world.task[ox][oy];
            item = this.world.items[ox][oy];
            height = this.world.map[ox][oy].get_vertical_offset();
            ix = x * this.tile_width - (y * this.tile_width);
            iy = y * this.tile_height + (x * this.tile_height);
            light = this.world.light[ox][oy];
            if (this.world.cloud[ox][oy] > 2) {
              light = light + 2;
            }
            if (height < this.world.water_level) {
              light = light + 10;
            }
            if (x === this.viewport_width || y === this.viewport_height || ox === this.world.width || oy === this.world.height) {
              for (h = k = -1, ref2 = height; -1 <= ref2 ? k <= ref2 : k >= ref2; h = -1 <= ref2 ? ++k : --k) {
                this.draw_tile(this.map_context, 3, ix, iy, h, 8 - h);
              }
            }
            this.draw_tile(this.map_context, tile, ix, iy, height, light);
            corner = true;
            if (oy > 1 && this.world.map[ox][oy - 1].height > height) {
              this.draw_tile(this.map_context, 18, ix, iy, height, light);
              corner = false;
            }
            if (ox > 1 && this.world.map[ox - 1][oy].height > height) {
              this.draw_tile(this.map_context, 19, ix, iy, height, light);
              corner = false;
            }
            if (ox > 1 && oy > 1 && corner && this.world.map[ox - 1][oy - 1].height > height) {
              this.draw_tile(this.map_context, 21, ix, iy, height, light);
            }
            if (item) {
              this.draw_tile(this.map_context, 20, ix, iy, height, light);
            }
            if (height < this.world.water_level) {
              this.draw_tile(this.map_context, 2, ix, iy, this.world.water_level, this.world.light[ox][oy]);
            }
            if (task) {
              if (task.work > 0) {
                this.draw_tile(this.map_context, 23, ix, iy, height, light);
                this.map_context.fillText(task.work, ix + this.tile_width / 2, (iy - height * 3) + 85);
              }
              if (!item) {
                this.map_context.fillText(task.abbr, ix + 17, (iy + height * 3) + 85);
              }
            }
            if (item) {
              this.draw_tile(this.map_context, item.get_tile(), ix, iy, height, light);
              if (item.count > 1) {
                this.map_context.fillText(item.count, ix + 17, (iy + height * 3) + 85);
              }
            }
            actor = this.world.actors[ox][oy];
            if (actor) {
              this.draw_tile(this.map_context, actor.get_tile(), ix, iy, height, light);
              if (actor.carry) {
                this.draw_tile(this.map_context, actor.carry.get_tile(), ix, iy, height + 1, light);
              }
            }
            if (this.world.cloud[ox][oy] > 2) {
              results1.push(this.draw_tile(this.map_context, 22, ix, iy, 8, light));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    return Render;

  })();

}).call(this);

//# sourceMappingURL=render.js.map
