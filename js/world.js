// Generated by CoffeeScript 1.9.2
(function() {
  window.Position = (function() {
    function Position(x, y) {
      this.x = x;
      this.y = y;
    }

    return Position;

  })();

  window.World = (function() {
    World.prototype.map = [];

    World.prototype.light = [];

    World.prototype.items = [];

    World.prototype.height_map = [];

    World.prototype.task = [];

    World.prototype.task_queue = [];

    World.prototype.actors = [];

    World.prototype.actor_queue = [];

    World.prototype.water_level = 0;

    World.prototype.next_id = 0;

    World.prototype.changed = true;

    World.prototype.version = 0;

    function World(width, height) {
      var i, ref, x;
      this.width = width;
      this.height = height;
      for (x = i = 1, ref = this.width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        this.height_map[x] = [];
        this.task[x] = [];
        this.items[x] = [];
        this.actors[x] = [];
        this.light[x] = [];
      }
    }

    World.prototype.get_access_map = function() {
      var access_map, i, j, ref, ref1, row, x, y;
      access_map = [0];
      for (x = i = 1, ref = this.width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        row = [0];
        for (y = j = 1, ref1 = this.height; 1 <= ref1 ? j <= ref1 : j >= ref1; y = 1 <= ref1 ? ++j : --j) {
          if (this.height_map[x][y] < this.water_level || this.actors[x][y]) {
            row.push(0);
          } else {
            row.push(1);
          }
        }
        access_map.push(row);
      }
      return access_map;
    };

    World.prototype.get_id = function() {
      this.next_id = this.next_id + 1;
      return this.next_id;
    };

    World.prototype.set = function(x, y, location_class) {
      return this.map[x][y] = new location_class(this, x, y, this.height_map[x][y]);
    };

    World.prototype.add_task = function(task) {
      this.task[task.x][task.y] = task;
      this.task_queue.push(task);
      return this.changed = true;
    };

    World.prototype.remove_task = function(task) {
      if (task.assigned) {
        task.assigned.invalidate();
      }
      this.task[task.x][task.y] = null;
      this.task_queue.splice(this.task_queue.indexOf(task), 1);
      return this.changed = true;
    };

    World.prototype.remove_task_on = function(x, y) {
      if (!this.task[x][y]) {
        return;
      }
      return this.remove_task(this.task[x][y]);
    };

    World.prototype.add_actor = function(actor) {
      this.actors[actor.x][actor.y] = actor;
      this.actor_queue.push(actor);
      return this.changed = true;
    };

    World.prototype.remove_actor = function(actor) {
      this.actors[actor.x][actor.y] = null;
      this.actor_queue.splice(this.actor_queue.indexOf(actor), 1);
      return this.changed = true;
    };

    World.prototype.add_item = function(item) {
      this.items[item.x][item.y] = item;
      this.items_changed = true;
      this.changed = true;
      return item.created();
    };

    World.prototype.remove_item = function(item) {
      this.items[item.x][item.y] = null;
      return this.changed = true;
    };

    World.prototype.item_at = function(object) {
      return this.items[object.x][object.y];
    };

    World.prototype.find_free_spot = function(start_x, start_y) {
      var distance, distance_to_item, i, j, location, ref, ref1, x, y;
      distance = null;
      location = null;
      for (x = i = 1, ref = this.width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        for (y = j = 1, ref1 = this.height; 1 <= ref1 ? j <= ref1 : j >= ref1; y = 1 <= ref1 ? ++j : --j) {
          if (this.items[x][y]) {
            continue;
          }
          distance_to_item = Math.abs(x - start_x) + Math.abs(y - start_y);
          if (distance === null || distance_to_item < distance) {
            location = {
              x: x,
              y: y
            };
            distance = distance_to_item;
          }
        }
      }
      return location;
    };

    World.prototype.find = function(x, y, range, check) {
      var i, ref, ref1, results, rx, ry;
      results = [];
      for (rx = i = ref = -range, ref1 = range; ref <= ref1 ? i <= ref1 : i >= ref1; rx = ref <= ref1 ? ++i : --i) {
        results.push((function() {
          var j, ref2, ref3, results1;
          results1 = [];
          for (ry = j = ref2 = -range, ref3 = range; ref2 <= ref3 ? j <= ref3 : j >= ref3; ry = ref2 <= ref3 ? ++j : --j) {
            if (x + rx <= 0) {
              continue;
            }
            if (y + ry <= 0) {
              continue;
            }
            if (x + rx > this.width) {
              continue;
            }
            if (y + ry > this.width) {
              continue;
            }
            results1.push(check(x + rx, y + ry));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    World.prototype.find_tasks = function(x, y, range) {
      var find_tasks;
      find_tasks = [];
      this.find(x, y, range, (function(_this) {
        return function(check_x, check_y) {
          if (_this.task[check_x][check_y]) {
            return find_tasks.push(_this.task[check_x][check_y]);
          }
        };
      })(this));
      return find_tasks;
    };

    World.prototype.move_actor = function(actor, x, y) {
      if (!this.reachable(x, y)) {
        return false;
      }
      this.actors[actor.x][actor.y] = null;
      actor.x = x;
      actor.y = y;
      return this.actors[actor.x][actor.y] = actor;
    };

    World.prototype.reachable = function(x, y) {
      if (x < 1 || y < 1) {
        return false;
      }
      if (this.actors[x][y]) {
        return false;
      }
      if (x > this.width || y > this.height) {
        return false;
      }
      if (this.height_map[x][y] < this.water_level) {
        return false;
      }
      return true;
    };

    World.prototype.smoothen = function(map, acount) {
      var avg, c, count, i, ox, oy, ref, results, x, y;
      results = [];
      for (c = i = 1, ref = acount; 1 <= ref ? i <= ref : i >= ref; c = 1 <= ref ? ++i : --i) {
        results.push((function() {
          var j, ref1, results1;
          results1 = [];
          for (x = j = 1, ref1 = this.width; 1 <= ref1 ? j <= ref1 : j >= ref1; x = 1 <= ref1 ? ++j : --j) {
            results1.push((function() {
              var k, l, m, ref2, results2;
              results2 = [];
              for (y = k = 1, ref2 = this.height; 1 <= ref2 ? k <= ref2 : k >= ref2; y = 1 <= ref2 ? ++k : --k) {
                avg = 0;
                count = 0;
                for (ox = l = -1; l <= 1; ox = ++l) {
                  for (oy = m = -1; m <= 1; oy = ++m) {
                    if (x + ox <= 0 || y + oy <= 0 || x + ox > this.width || y + oy > this.height) {
                      continue;
                    }
                    if (ox === 0 && oy === 0) {
                      continue;
                    }
                    avg = avg + map[x + ox][y + oy];
                    count = count + 1;
                  }
                }
                results2.push(map[x][y] = avg / count);
              }
              return results2;
            }).call(this));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    World.prototype.normalize = function(map, norm) {
      var i, j, k, max, ref, ref1, ref2, results, x, y;
      max = 0;
      for (x = i = 1, ref = this.width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        for (y = j = 1, ref1 = this.height; 1 <= ref1 ? j <= ref1 : j >= ref1; y = 1 <= ref1 ? ++j : --j) {
          if (map[x][y] > max) {
            max = map[x][y];
          }
        }
      }
      results = [];
      for (x = k = 1, ref2 = this.width; 1 <= ref2 ? k <= ref2 : k >= ref2; x = 1 <= ref2 ? ++k : --k) {
        results.push((function() {
          var l, ref3, results1;
          results1 = [];
          for (y = l = 1, ref3 = this.height; 1 <= ref3 ? l <= ref3 : l >= ref3; y = 1 <= ref3 ? ++l : --l) {
            results1.push(map[x][y] = Math.round((map[x][y] / max) * norm, 1));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    World.prototype.create_height_map = function() {
      var i, j, ref, ref1, x, y;
      for (x = i = 1, ref = this.width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        this.height_map[x] = [];
        for (y = j = 1, ref1 = this.height; 1 <= ref1 ? j <= ref1 : j >= ref1; y = 1 <= ref1 ? ++j : --j) {
          this.height_map[x][y] = 2;
          if (Math.round(Math.random() * 20) === 1) {
            this.height_map[x][y] = Math.floor(Math.random() * 1000) - 500;
          }
        }
      }
      this.smoothen(this.height_map, 20);
      return this.normalize(this.height_map, 4);
    };

    World.prototype.find_item = function(start_x, start_y, object, in_pile) {
      var distance, distance_to_item, found_item, i, item, j, ref, ref1, x, y;
      distance = null;
      found_item = null;
      for (x = i = 1, ref = this.width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        for (y = j = 1, ref1 = this.height; 1 <= ref1 ? j <= ref1 : j >= ref1; y = 1 <= ref1 ? ++j : --j) {
          item = this.items[x][y];
          if (!item) {
            continue;
          }
          if (!(item instanceof object)) {
            continue;
          }
          if (in_pile === false && this.task[x][y] instanceof window.PileTask) {
            continue;
          }
          if (in_pile === true && !(this.task[x][y] instanceof window.PileTask)) {
            continue;
          }
          if (!this.reachable(x, y) && (x !== start_x && y !== start_y)) {
            continue;
          }
          distance_to_item = Math.abs(x - start_x) + Math.abs(y, start_y);
          if (distance === null || distance_to_item < distance) {
            distance = distance_to_item;
            found_item = item;
          }
        }
      }
      console.debug("Search for ", object, "resulted in", found_item);
      return found_item;
    };

    World.prototype.cycle = function() {
      var i, ref, results, x, y;
      results = [];
      for (x = i = 1, ref = this.width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        results.push((function() {
          var j, ref1, results1;
          results1 = [];
          for (y = j = 1, ref1 = this.height; 1 <= ref1 ? j <= ref1 : j >= ref1; y = 1 <= ref1 ? ++j : --j) {
            if (!this.items[x][y]) {
              continue;
            }
            results1.push(this.items[x][y].cycle());
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    World.prototype.generate = function() {
      var i, ref, results, x, y;
      this.create_height_map();
      results = [];
      for (x = i = 1, ref = this.width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        this.map[x] = [];
        results.push((function() {
          var j, ref1, results1;
          results1 = [];
          for (y = j = 1, ref1 = this.height; 1 <= ref1 ? j <= ref1 : j >= ref1; y = 1 <= ref1 ? ++j : --j) {
            results1.push(this.map[x][y] = new window.Grass(this, x, y, this.height_map[x][y]));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    World.prototype.lightmap = function() {
      var factor, i, j, k, max_height, ref, ref1, ref2, results, x, y;
      max_height = 0;
      for (x = i = 1, ref = this.width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        for (y = j = 1, ref1 = this.height; 1 <= ref1 ? j <= ref1 : j >= ref1; y = 1 <= ref1 ? ++j : --j) {
          if (this.height_map[x][y] > max_height) {
            max_height = this.height_map[x][y];
          }
        }
      }
      factor = 6 / max_height;
      results = [];
      for (x = k = 1, ref2 = this.width; 1 <= ref2 ? k <= ref2 : k >= ref2; x = 1 <= ref2 ? ++k : --k) {
        this.light[x] = [];
        results.push((function() {
          var l, ref3, results1;
          results1 = [];
          for (y = l = 1, ref3 = this.height; 1 <= ref3 ? l <= ref3 : l >= ref3; y = 1 <= ref3 ? ++l : --l) {
            results1.push(this.light[x][y] = parseInt(factor * (max_height - this.height_map[x][y]), 10) + parseInt(Math.random() * 2, 10));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    World.prototype.populate = function() {
      var i, j, k, plains, ref, ref1, ref2, results, x, y;
      plains = [];
      for (x = i = 1, ref = this.width; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        plains[x] = [];
        for (y = j = 1, ref1 = this.height; 1 <= ref1 ? j <= ref1 : j >= ref1; y = 1 <= ref1 ? ++j : --j) {
          plains[x][y] = Math.floor(Math.random() * 10);
        }
      }
      this.smoothen(plains, 6);
      this.normalize(plains, 3);
      this.lightmap();
      results = [];
      for (x = k = 1, ref2 = this.width; 1 <= ref2 ? k <= ref2 : k >= ref2; x = 1 <= ref2 ? ++k : --k) {
        this.map[x] = [];
        results.push((function() {
          var l, ref3, results1;
          results1 = [];
          for (y = l = 1, ref3 = this.height; 1 <= ref3 ? l <= ref3 : l >= ref3; y = 1 <= ref3 ? ++l : --l) {
            this.map[x][y] = new window.Grass(this, x, y, this.height_map[x][y]);
            if (plains[x][y] === 1) {
              this.map[x][y] = new window.Grass(this, x, y, this.height_map[x][y]);
            }
            if (Math.floor(Math.random() * 50) === 1) {
              this.items[x][y] = new window.Wheat(this, x, y, this.height_map[x][y]);
            }
            if (plains[x][y] === 3) {
              this.items[x][y] = new window.Tree(this, x, y, this.height_map[x][y]);
            }
            if (this.height_map[x][y] < this.water_level) {
              this.map[x][y] = new window.Water(this, x, y, this.height_map[x][y]);
              results1.push(this.items[x][y] = null);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    return World;

  })();

}).call(this);

//# sourceMappingURL=world.js.map
